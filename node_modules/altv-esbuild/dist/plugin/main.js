var B=Object.defineProperty;var P=(a,e,t)=>e in a?B(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var g=(a,e,t)=>(P(a,typeof e!="symbol"?e+"":e,t),t);var v={mode:"client",dev:{enabled:!0,hotReload:!0,hotReloadServerPort:8877,playersReconnect:!0,playersReconnectDelay:200,playersReconnectResetPos:!0,connectionCompleteEvent:!0,disconnectEvent:!0,restartCommand:!0,topLevelExceptionHandling:!0,moveExternalsOnTop:!0,enhancedRestartCommand:!1},bugFixes:{webViewFlickering:!0,playerPrototype:!0},altvEnums:!1,enhancedAltLog:!0};var C=({mode:a,dev:e,bugFixes:t,altvEnums:n,enhancedAltLog:r})=>{if(typeof a==null)throw new Error('mode option must be provided: "server" or "client"');return e??=!1,{mode:a,dev:e===!0?{...v.dev,enabled:!0}:e===!1?{...Object.fromEntries(Object.entries(v.dev).map(([o,i])=>[o,typeof i=="boolean"?!1:-1])),enabled:!1}:{...v.dev,...e,playersReconnectResetPos:e.playersReconnectResetPos??e.playersReconnect??v.dev.playersReconnectResetPos},bugFixes:t===!0?v.bugFixes:{...v.bugFixes,...t},altvEnums:n??v.altvEnums,enhancedAltLog:r??v.enhancedAltLog}};var d="altv-esbuild";var f=class{receiver;sender;constructor(e,t,n){this.isCommunicatorSenderAndReceiver(e)?(this.sender=e.sender??null,this.receiver=e.receiver??null):(this.sender=e,this.receiver=e),this.receiver?.on("data",r=>{r=r.toString();for(let o of r.split("|"))if(!!o)try{let{event:i,args:h}=JSON.parse(o),s=t[i];if(!s){n(`received unknown event: ${i}`);return}s(...h)}catch(i){n(`failed to handle chunk: '${o}' error: ${i?.stack}`)}}),this.receiver?.on("error",r=>{r?.code==="ECONNRESET"||r?.code==="ECONNREFUSED"||n(`socket error: ${r.stack}`,r)})}send(e,...t){if(!this.sender)throw new Error("EventManager cannot send since sender was not provided");let n={args:t,event:e};this.sender.write(JSON.stringify(n)+"|")}destroy(){this.receiver?.removeAllListeners("data"),this.receiver?.removeAllListeners("error")}isCommunicatorSenderAndReceiver(e){return!!(e.sender||e.receiver)}};var x=class{constructor(e){this.name=e;this.debug=()=>{}}debug;info(...e){console.log(`${x.CONSOLE_BLUE}[${d}][${this.name}]${x.CONSOLE_RESET}`,...e)}error(...e){console.error(`${x.CONSOLE_RED}[ERROR] [${d}][${this.name}]`,...e)}},l=x;g(l,"CONSOLE_BLUE","\x1B[34m"),g(l,"CONSOLE_RESET","\x1B[0m"),g(l,"CONSOLE_RED","\x1B[31m");var c=a=>"___altvEsbuild_"+a.replace(/[-/\\ @.]/g,"_x_")+"___";import N from"fs";var p=c("altvInject_altShared"),u=c("altvInject_alt"),O=c("altvInject_native"),y=(n=>(n[n.None=0]="None",n[n.Start=1]="Start",n[n.End=2]="End",n))(y||{});var E=class{constructor(e,t){this.options=e;this.build=t;this._log=new l(`shared: ${e.mode}`),this.addExternalImportHandling(t,"alt-shared",p),this.addExternalImportHandling(t,"alt",u),e.altvEnums&&this.addCustomModule(t,"altv-enums",N.readFileSync(new URL("../../altv-enums/dist/enums.js",import.meta.url)).toString())}_log;bannerImportsCode=`// banner imports
`;bannerBodyCode=`// banner body
`;handleBuildOptions(){let{banner:e,footer:t,external:n}=this.build.initialOptions,r={banner:{...e,js:e?.js??""},footer:{...t,js:t?.js??""},external:n?[...n]:[]};this.bannerImportsCode+=`const ${c("altvInject_pluginOptions")} = ${JSON.stringify(this.options)};
`;let o=r.external.indexOf("alt"),i=r.external.indexOf("alt-shared");return o!==-1&&r.external.splice(o,1),i!==-1&&r.external.splice(i,1),r}appendBannerJs(e,t,n,r){this.appendCodeTo(e,"banner",t,n,r)}appendCodeTo(e,t,n,r=!0,o=""){e[t].js+=`${n}${r?";":""}${o?` // ${o}`:""}
`}endBannerJs(e){let t="";this.options.dev.topLevelExceptionHandling&&(t+="try {"),e.banner.js+=`// ------------------- ${d} banner -------------------
`+this.bannerImportsCode+`await (async () => { // start banner wrapper
`+N.readFileSync(new URL("../altv-inject/main.js",import.meta.url)).toString()+`})().catch(e => ${p}.logError("[altv-esbuild] banner wrapper error:", e?.stack ?? e?.message ?? e));
`+t+`// ------------------- ${d} banner -------------------
`}endFooterJs(e){let t="";this.options.dev.topLevelExceptionHandling&&(t+=`} catch (e) {
        const error = ${p}.logError;

        // hide all other user logs to show error at a glance
        ${p}.log = () => {};
        ${p}.logWarning = () => {};
        ${p}.logError = () => {};
        ${u}.log = () => {};
        ${u}.logWarning = () => {};
        ${u}.logError = () => {};
        console.log = () => {};
        console.warn = () => {};
        console.error = () => {};

        ${p}.setTimeout(() => {
          error(
            "[${d}] Top-level exception:\\n  ",
            e?.stack ?? e
          );
        }, 500);
        if (${u}.isClient) {
          drawError("TOP-LEVEL EXCEPTION", "see client console", "(it's message from altv-esbuild)");
          function drawError(title,text,text2){
            const alt = ${u};
            alt.addGxtText("warning_error",title);
            alt.addGxtText("warning_text",text);
            alt.addGxtText("warning_text2",text2);
            let state=!alt.isConsoleOpen();
            const timeout=alt.setInterval(()=>{state=!alt.isConsoleOpen()},50);
            const tick=alt.everyTick(()=>{
              if (state) {
                ${O}.setWarningMessageWithHeader(
                  "warning_error",
                  "warning_text",
                  0,
                  "warning_text2",
                  false, -1,
                  null, null,
                  true, 0
                );
              }
            });
            return()=>{alt.clearInterval(timeout);alt.clearEveryTick(tick)}
          }
        }
      }`),e.footer.js+=`
// ------------------- ${d} footer -------------------
`+t+`
// ------------------- ${d} footer -------------------
`}addExternalImportHandling(e,t,n){let r=`${d}:external-handling-${t}`;this.bannerImportsCode.includes(`import ${n} from`)||(this.bannerImportsCode+=`import ${n} from "${t}";
`),e.onResolve({filter:new RegExp(`^${t}$`)},o=>({path:o.path,namespace:r})),e.onLoad({filter:/.*/,namespace:r},()=>({contents:`module.exports = ${n}`}))}addCustomModule(e,t,n){let r=`${d}:custom-module-${t}`;e.onResolve({filter:new RegExp(`^${t}$`)},o=>({path:o.path,namespace:r})),e.onLoad({filter:/.*/,namespace:r},()=>({contents:n,loader:"js"}))}enableMoveExternalImportsOnTop({external:e},t,n,r){let o=`${d}:externals-on-top`,i=[...e,...t??[]].join("|"),h={};this.bannerImportsCode+=`// ----------------- external imports on top -----------------
`,n&&(this.bannerImportsCode+=`// ----------- additional top -----------
`,this.bannerImportsCode+=n,this.bannerImportsCode+=`// ----------- additional top -----------
`);for(let s of e){if(s.includes("*")){let b=`external name: ${s} "*" wildcard character is not supported yet`;throw this._log.error(b),this._log.error("(this error came from plugin option moveExternalsOnTop"),this._log.error("that can be disabled if you are not using externals with enabled topLevelExceptionHandling)"),new Error(b)}let m=c(`externalOnTop_${s}`);h[s]=m,this.bannerImportsCode+=`import * as ${m} from "${s}";
`}for(let s of t??[])h[s]=c(`additional_externalOnTop_${s}`);this.bannerImportsCode+=`// ----------------- external imports on top -----------------
`,this.build.onResolve({filter:new RegExp(`^(${i})$`)},({path:s})=>{let m=h[s];if(!m){let b=`external: ${s} var name not found`;throw this._log.error(b),new Error(b)}return{path:s,namespace:o,pluginData:m}}),this.build.onLoad({filter:/.*/,namespace:o},({pluginData:s,path:m})=>({contents:r?.(m,s)??`
            Object.defineProperty(exports, '__esModule', { value: true })
            for (const key in ${s}) {
              exports[key] = ${s}[key]
            }
        `}))}};import w from"net";var S=class{constructor(e,t,n){this._net=e;this.port=t;this.connectHandler=n;this._socket=this.connect()}onError=e=>{(e?.code==="ECONNRESET"||e?.code==="ECONNREFUSED")&&(S.logDebug(`disconnected from server, trying reconnecting in ${S.RECONNECT_MS}ms...`),setTimeout(()=>this.connect(),S.RECONNECT_MS))};onConnect=e=>{this.connectHandler(e)};_socket;get socket(){return this._socket}connect(){this._socket&&this._socket.destroy();let e=this._net.connect(this.port);return e.on("connect",this.onConnect.bind(this,e)),e.on("error",this.onError),e}},_=S;g(_,"RECONNECT_MS",500),g(_,"logDebug",()=>{});var I=class extends E{events={buildEnd:()=>{},buildStart:()=>{},clientConnect:()=>{},clientDisconnect:()=>{}};onConnect=()=>{this.log.info("connected to server"),this.eventManager?.send("connect","client")};log=new l("client");socket;eventManager;socketConnect;constructor(e,t){super(e,t);let{dev:n}=e;n.hotReload&&(this.socketConnect=new _(w,this.options.dev.hotReloadServerPort,r=>{this.socket=r,this.eventManager=new f(this.socket,this.events,o=>this.log.error("[events]",o)),this.onConnect()}),t.onStart(()=>{this.eventManager?.send("clientBuildStart")}),t.onEnd(({errors:r})=>{if(r.length){this.log.debug("client build end errors");return}this.eventManager?.send("clientBuildEnd")})),this.addExternalImportHandling(t,"alt-client",u),this.addExternalImportHandling(t,"natives",O)}handleBuildOptions(){let e=super.handleBuildOptions(),t=e.external.indexOf("alt-client");t!==-1&&e.external.splice(t,1);let n=e.external.indexOf("natives");return n!==-1&&e.external.splice(n,1),this.options.dev.moveExternalsOnTop&&this.enableMoveExternalImportsOnTop(e),this.endBannerJs(e),this.endFooterJs(e),e}};import T from"net";var k=class{constructor(e,t,n,r,o){this.mode=e;this.port=t;this.connectModeHandler=n;this.clientBuildStartHandler=r;this.clientBuildEndHandler=o;this.tryListen(t),this.server.on("error",this.onError),this.server.on("listening",this.onStartListening),this.onErrorAddrInUse=()=>{this.log.error("port:",this.port,"already in use"),process.exit()}}onStartListening=()=>{this.log.info("started listening on port:",this.port)};onConnect=e=>{this.log.debug("some client connected");let t="unknown",n=new f(e,{connect:r=>{if(this._sockets[r]){this.log.error(`another socket mode: ${r} is connected currently`),e.destroy(),n.destroy();return}t=r,this.log.info(`connected socket mode: ${r}`),this._sockets[r]={socket:e,eventManager:n},e.on("close",this.onSocketClose.bind(this,r)),(r==="client"||r==="server"&&this._sockets.client)&&this._sockets.server?.eventManager.send("clientConnect"),this.connectModeHandler(r)},clientBuildStart:()=>{this.clientBuildStartHandler()},clientBuildEnd:()=>{this.clientBuildEndHandler()}},(r,o)=>this.onSocketError(t,r,o))};onError=e=>{e.code==="EADDRINUSE"&&this.onErrorAddrInUse(),this.log.error("server error:",e)};onSocketError=(e,t,n)=>{if(n?.code==="ECONNRESET"){this.log.debug(`disconnected socket mode: ${e}`);return}this.log.error(`socket mode: ${e} error:`,n)};onSocketClose=e=>{this._sockets[e]?.eventManager.destroy(),this._sockets[e]=null,this.log.info(`disconnected socket mode: ${e}`)};log=new l("NetServer");server=new T.Server(this.onConnect);onErrorAddrInUse;_sockets={client:null,server:null};get sockets(){return this._sockets}sendEvent(e,t,...n){let r=this._sockets[e];if(!r){this.log.error(`[sendEvent] event: ${t} no target socket mode: ${e}`);return}r.eventManager.send(t,...n)}tryListen(e){this.server.listen(e)}};var $=["_http_agent","_http_client","_http_common","_http_incoming","_http_outgoing","_http_server","_stream_duplex","_stream_passthrough","_stream_readable","_stream_transform","_stream_wrap","_stream_writable","_tls_common","_tls_wrap","assert","assert/strict","async_hooks","buffer","child_process","cluster","console","constants","crypto","dgram","diagnostics_channel","dns","dns/promises","domain","events","fs","fs/promises","http","http2","https","inspector","module","net","os","path","path/posix","path/win32","perf_hooks","process","punycode","querystring","readline","repl","stream","stream/consumers","stream/promises","stream/web","string_decoder","sys","timers","timers/promises","tls","trace_events","tty","url","util","util/types","v8","vm","wasi","worker_threads","zlib"];var R=class extends E{hotReloadServer;log=new l("server");cachedBuildState={client:0,server:0};wasConnectedOnce={client:!1,server:!1};onConnectSomeMode=e=>{if(!this.wasConnectedOnce[e]){this.wasConnectedOnce[e]=!0;return}let t=this.cachedBuildState[e];if(t!==0){switch(this.log.debug("onConnectSomeMode:",e,"-> sending cached build event:",y[t]),t){case 1:this.sendBuildStart(e,!0);break;case 2:this.sendBuildEnd(e,!0);break}this.cachedBuildState[e]=0}};onClientBuildStart=()=>{if(this.log.debug("onClientBuildStart"),this.cacheBuildStateIfNeeded("client",2)){this.log.debug("onClientBuildStart but server socket is not connected -> send it on connect");return}!this.hotReloadServer?.sockets.server||(this.log.debug("onClientBuildStart, send server altv-inject buildStart event"),this.sendBuildStart("client"))};onClientBuildEnd=()=>{if(this.log.debug("onClientBuildEnd"),this.cacheBuildStateIfNeeded("client",2)){this.log.debug("onClientBuildEnd but server socket is not connected -> send it on connect");return}!this.hotReloadServer?.sockets.server||(this.log.debug("onClientBuildEnd, send server altv-inject BuildEnd event"),this.sendBuildEnd("client"))};constructor(e,t){super(e,t);let{mode:n,dev:r}=e;if(r.enabled&&r.hotReload){let o=new k(n,r.hotReloadServerPort,this.onConnectSomeMode,this.onClientBuildStart,this.onClientBuildEnd);this.hotReloadServer=o;let i=this.cacheBuildStateIfNeeded.bind(this,"server");t.onEnd(({errors:h})=>{if(h.length){this.log.debug("build.onEnd errors");return}if(this.log.debug("server buildEnd"),i(2)){this.log.debug("buildEnd but server socket is not connected -> send it on connect");return}!o.sockets.server||(this.log.debug("send buildEnd"),this.sendBuildEnd("server"))}),t.onStart(()=>{if(i(1)){this.log.debug("buildStart but server socket is not connected -> send it on connect");return}!o.sockets.server||(this.log.debug("send buildStart"),this.sendBuildStart("server"))})}this.addExternalImportHandling(t,"alt-server",u)}handleBuildOptions(){let e=super.handleBuildOptions(),t=e.external.indexOf("alt-server");if(t!==-1&&e.external.splice(t,1),this.options.dev.moveExternalsOnTop){let n=c("createRequire"),r=c("customRequire");this.enableMoveExternalImportsOnTop(e,$,`import { createRequire as ${n} } from 'module';
const ${r} = ${n}(import.meta.url);
`,(o,i)=>`
            try {
              module.exports = ${r}('${o}')
            } catch (e) {
              if (e.code !== 'ERR_REQUIRE_ESM') {
                try {
                  ${p}.nextTick(() => ${p}.logError(e?.stack))
                } catch {}
              }
              Object.defineProperty(exports, '__esModule', { value: true })
              for (const key in ${i}) {
                exports[key] = ${i}[key]
              }
            }
          `)}return this.endBannerJs(e),this.endFooterJs(e),e}sendBuildStart(e,t=!1){this.hotReloadServer?.sendEvent("server","buildStart",e,t)}sendBuildEnd(e,t=!1){this.hotReloadServer?.sendEvent("server","buildEnd",e,t)}cacheBuildStateIfNeeded(e,t){return this.hotReloadServer?.sockets.server||!this.wasConnectedOnce[e]?!1:this.cachedBuildState[e]===t?(this.log.debug("[cacheBuildStateIfNeeded] mode:",e,y[t],"already cached"),!0):(this.log.debug("cache mode:",e,"buildState:",y[t]),this.cachedBuildState[e]=t,!0)}};var We=a=>{let e=C(a);return new l("plugin").debug("merged options:",e),{name:d,setup(n){let{initialOptions:r}=n,i=(e.mode==="client"?new I(e,n):new R(e,n)).handleBuildOptions();Object.assign(r,i)}}};export{We as altvEsbuild};
